# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T12:30:27+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path, Query

from models import (
    AccountHistoricalBalancesResponse,
    AccountResponse,
    Action,
    ApiKeyRequest,
    ApiKeyResponse,
    ClientCredentialTokenResponse,
    CobrandLoginRequest,
    CobrandLoginResponse,
    CobrandNotificationResponse,
    CobrandPublicKeyResponse,
    ConfigsNotificationResponse,
    ConfigsPublicKeyResponse,
    CreateAccountRequest,
    CreateCobrandNotificationEventRequest,
    CreateConfigsNotificationEventRequest,
    CreatedAccountResponse,
    DataExtractsEventResponse,
    DataExtractsUserDataResponse,
    DerivedHoldingSummaryResponse,
    DerivedNetworthResponse,
    DerivedTransactionSummaryResponse,
    DocumentDownloadResponse,
    DocumentResponse,
    EvaluateAddressRequest,
    EvaluateAddressResponse,
    EventName,
    HoldingAssetClassificationListResponse,
    HoldingResponse,
    HoldingSecuritiesResponse,
    HoldingTypeListResponse,
    ProviderAccountDetailResponse,
    ProviderAccountPreferencesRequest,
    ProviderAccountRequest,
    ProviderAccountResponse,
    ProviderAccountUserProfileResponse,
    ProviderDetailResponse,
    ProviderResponse,
    ProvidersCountResponse,
    StatementResponse,
    TransactionCategorizationRuleRequest,
    TransactionCategorizationRuleResponse,
    TransactionCategoryRequest,
    TransactionCategoryResponse,
    TransactionCountResponse,
    TransactionRequest,
    TransactionResponse,
    TransactionsCategoriesRulesGetResponse,
    UpdateAccountRequest,
    UpdateCategoryRequest,
    UpdateCobrandNotificationEventRequest,
    UpdateConfigsNotificationEventRequest,
    UpdatedProviderAccountResponse,
    UpdateUserRequest,
    UpdateVerificationRequest,
    UserAccessTokensResponse,
    UserDetailResponse,
    UserRequest,
    UserResponse,
    VerificationRequest,
    VerificationResponse,
    VerificationStatusResponse,
    VerifyAccountRequest,
    VerifyAccountResponse,
    YodleeError,
)

app = MCPProxy(
    contact={'email': 'developer@yodlee.com'},
    description='This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href="https://developer.yodlee.com/java-sdk-overview ">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href="https://developer.yodlee.com/docs/api/1.1/Overview">Yodlee API v1.1 - Overview</a>.',
    license={
        'name': 'Yodlee Developer License',
        'url': 'https://developer.yodlee.com/terms/condition#_Services_1',
    },
    termsOfService='https://developer.yodlee.com/terms/condition',
    title='Yodlee Core APIs',
    version='1.1.0',
    servers=[{'url': '/'}],
)


@app.get(
    '/accounts',
    description=""" The get accounts service provides information about accounts added by the user.<br>By default, this service returns information for active and to be closed accounts.<br>If requestId is provided, the accounts that are updated in the context of the requestId will be provided in the response.<br><br><b>Note:</b><br><li>fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</li><li>fullAccountNumberList, PII (Personal Identifiable Information) and holder details are not available by default, as it is a premium feature that needs security approval. This will not be available for testing in Sandbox environment.</li> """,
    tags=['user_account_management', 'provider_account_management'],
)
def get_all_accounts(
    account_id: Optional[str] = Query(None, alias='accountId'),
    container: Optional[str] = None,
    include: Optional[str] = None,
    provider_account_id: Optional[str] = Query(None, alias='providerAccountId'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    status: Optional[str] = None,
):
    """
    Get Accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts',
    description=""" The add account service is used to add manual accounts.<br>The response of add account service includes the account name , account number and Yodlee generated account id.<br>All manual accounts added will be included as part of networth calculation by default.<br>Add manual account support is available for bank, card, investment, insurance and loan container only.<br><br><b>Note:</b> <li>A real estate account addition is only supported for SYSTEM and MANUAL valuation type.</li> """,
    tags=['user_account_management', 'user_management'],
)
def create_manual_account(body: CreateAccountRequest):
    """
    Add Manual Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts/evaluateAddress',
    description=""" Use this service to validate the address before adding the real estate account.<br>If the address is valid, the service will return the complete address information.<br>The response will contain multiple addresses if the user-provided input matches with multiple entries in the vendor database.<br>In the case of multiple matches, the user can select the appropriate address from the list and then invoke the add account service with the complete address.<br><br><b>Note:</b> <li>Yodlee recommends to use this service before adding the real estate account to avoid failures.</li> """,
    tags=['user_management', 'user_profile_management'],
)
def evaluate_address(body: EvaluateAddressRequest):
    """
    Evaluate Address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/historicalBalances',
    description=""" The historical balances service is used to retrieve the historical balances for an account or a user.<br>Historical balances are daily (D), weekly (W), and monthly (M). <br>The interval input should be passed as D, W, and M to retrieve the desired historical balances. The default interval is daily (D). <br>When no account id is provided, historical balances of the accounts that are active, to be closed, and closed are provided in the response. <br>If the fromDate and toDate are not passed, the last 90 days of data will be provided. <br>The fromDate and toDate should be passed in the YYYY-MM-DD format. <br>The date field in the response denotes the date for which the balance is requested.<br>includeCF needs to be sent as true if the customer wants to return carried forward balances for a date when the data is not available. <br>asofDate field in the response denotes the date as of which the balance was updated for that account.<br>When there is no balance available for a requested date and if includeCF is sent as true, the previous date for which the balance is available is provided in the response. <br>When there is no previous balance available, no data will be sent. """,
    tags=[
        'user_account_management',
        'user_data_extraction',
        'financial_summary_management',
    ],
)
def get_historical_balances(
    account_id: Optional[str] = Query(None, alias='accountId'),
    from_date: Optional[str] = Query(None, alias='fromDate'),
    include_c_f: Optional[bool] = Query(None, alias='includeCF'),
    interval: Optional[str] = None,
    skip: Optional[int] = None,
    to_date: Optional[str] = Query(None, alias='toDate'),
    top: Optional[int] = None,
):
    """
    Get Historical Balances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/accounts/{accountId}',
    description=""" The delete account service allows an account to be deleted.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br> """,
    tags=['user_account_management', 'user_management'],
)
def delete_account(account_id: int = Path(..., alias='accountId')):
    """
    Delete Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/{accountId}',
    description=""" The get account details service provides detailed information of an account.<br><br><b>Note:</b><li>fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</li> """,
    tags=['user_account_management', 'user_profile_management'],
)
def get_account(
    account_id: int = Path(..., alias='accountId'), include: Optional[str] = None
):
    """
    Get Account Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/accounts/{accountId}',
    description=""" The update account service is used to update manual and aggregated accounts.<br>The HTTP response code is 204 (Success without content).<br>Update manual account support is available for bank, card, investment, insurance, loan, otherAssets, otherLiabilities and realEstate containers only.<br><br><b>Note:</b><li> A real estate account update is only supported for SYSTEM and MANUAL valuation type.</li><li> Attribute <b>isEbillEnrolled</b> is deprecated as it is applicable for bill accounts only.</li> """,
    tags=['user_account_management', 'user_management'],
)
def update_account(
    account_id: int = Path(..., alias='accountId'), body: UpdateAccountRequest = ...
):
    """
    Update Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/auth/apiKey',
    description=""" This endpoint provides the list of API keys that exist for a customer.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol><b>Notes:</b><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment.  """,
    tags=['api_key_management'],
)
def get_api_keys():
    """
    Get API Keys
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/apiKey',
    description=""" This endpoint is used to generate an API key. The RSA public key you provide should be in 2048 bit PKCS#8 encoded format. <br>A public key is a mandatory input for generating the API key.<br/>The public key should be a unique key. The apiKeyId you get in the response is what you should use to generate the JWT token.<br> You can use one of the following authorization methods to access<br/>this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> Alternatively, you can use base 64 encoded cobrandLogin and cobrandPassword in the Authorization header (Format: Authorization: Basic <encoded value of cobrandLogin: cobrandPassword>)<br><br><b>Note:</b><br><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. The content type has to be passed as application/json for the body parameter.</li> """,
    tags=['api_key_management'],
)
def generate_api_key(body: ApiKeyRequest):
    """
    Generate API Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/auth/apiKey/{key}',
    description=""" This endpoint allows an existing API key to be deleted.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> <b>Notes:</b> <li>This service is not available in developer sandbox environment and will be made availablefor testing in your dedicated environment.  """,
    tags=['api_key_management', 'user_account_management'],
)
def delete_api_key(key: str):
    """
    Delete API Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/auth/token',
    description=""" This endpoint revokes the token passed in the Authorization header. This service is applicable for JWT-based (and all API key-based) authentication and also client credential (clientId and secret) based authentication. This service does not return a response body. The HTTP response code is 204 (success with no content). <br>Tokens generally have limited lifetime of up to 30 minutes. You will call this service when you finish working with one user, and you want to delete the valid token rather than simply letting it expire.<br><br><b>Note:</b> <li>Revoking an access token (either type, admin or a user token) can take up to 2 minutes, as the tokens are stored on a distributed system.<br/> """,
    tags=['api_key_management', 'user_management'],
)
def delete_token():
    """
    Delete Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/token',
    description=""" <b>Generate Access Token using client credential authentication.</b><br>This service returns access tokens required to access Yodlee 1.1 APIs. These tokens are the simplest and easiest of several alternatives for authenticating with Yodlee servers.<br>The most commonly used services obtain data specific to an end user (your customer). For these services, you need a <b>user access token</b>. These are simply tokens created with the user name parameter (<b>loginName</b>) set to the id of your end user.  <i><br><br><b>Note:</b> You determine this id and you must ensure it's unique among all your customers.</i> <br><br>Each token issued has an associated user. The token passed in the http headers explicitly names the user referenced in that API call.<br><br>Some of the APIs do administrative work, and don't reference an end user. <br/>One example of administrative work is key management. Another example is registering a new user explicitly, with <b>POST /user/register</b> call or subscribe to webhook, with <b>POST /config/notifications/events/{eventName}</b>. <br/>To invoke these, you need an <b>admin access token</b>. Create this by passing in your admin user login name in place of a regular user name.<br><br>This service also allows for simplified registration of new users. Any time you pass in a user name not already in use, the system will automatically implicitly create a new user for you. <br>This user will naturally have very few associated details. You can later provide additional user information by calling the <b>PUT user/register service</b>.<br><br><b>Notes:</b><li>The content type has to be passed as application/x-www-form-urlencoded.<li>Upgrading to client credential authentication requires infrastructure reconfiguration. <li>Customers wishing to switch from another authentication scheme to client credential authentication, please contact Yodlee Client Services.</li> """,
    tags=['user_authentication', 'authentication_method_management'],
)
def generate_access_token():
    """
    Generate Access Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cobrand/config/notifications/events',
    description=""" <b>Refer GET /configs/notifications/events.</b><br>The get events service provides the list of events for which consumers subscribed <br>to receive notifications. <br> """,
    tags=['event_subscription_management'],
)
def get_subscribed_events(
    event_name: Optional[EventName] = Query(None, alias='eventName')
):
    """
    Get Subscribed Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/cobrand/config/notifications/events/{eventName}',
    description=""" <b>Refer DELETE /configs/notifications/events/{eventName}.</b><br>The delete events service is used to unsubscribe from an events service.<br> """,
    tags=['event_subscription_management', 'user_account_management'],
)
def delete_subscribed_event(event_name: EventName = Path(..., alias='eventName')):
    """
    Delete Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/cobrand/config/notifications/events/{eventName}',
    description=""" <b>Refer POST /configs/notifications/events/{eventName}.</b><br>The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES and AUTO_REFRESH_UPDATES event.<br><br><b>Notes</b>:<br>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<br>The content type has to be passed as application/json for the body parameter.<br> """,
    tags=['event_subscription_management'],
)
def create_subscription_event(
    event_name: EventName = Path(..., alias='eventName'),
    body: CreateCobrandNotificationEventRequest = ...,
):
    """
    Subscribe Event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/cobrand/config/notifications/events/{eventName}',
    description=""" <b>Refer PUT /configs/notifications/events/{eventName}.</b><br>The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><b>Note:</b> The content type has to be passed as application/json for the body parameter. <br> """,
    tags=['event_subscription_management'],
)
def update_subscribed_event(
    event_name: EventName = Path(..., alias='eventName'),
    body: UpdateCobrandNotificationEventRequest = ...,
):
    """
    Update Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/cobrand/login',
    description=""" The cobrand login service authenticates a cobrand.<br>Cobrand session in the response includes the cobrand session token (cobSession) <br>which is used in subsequent API calls like registering or signing in the user. <br>The idle timeout for a cobrand session is 2 hours and the absolute timeout is 24 hours. This service can be <br>invoked to create a new cobrand session token. <br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>The content type has to be passed as application/json for the body parameter. <br> """,
    tags=['user_authentication', 'user_management'],
)
def cobrand_login(body: CobrandLoginRequest):
    """
    Cobrand Login
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/cobrand/logout',
    description=""" The cobrand logout service is used to log out the cobrand.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br> """,
    tags=['user_management', 'user_authentication'],
)
def cobrand_logout():
    """
    Cobrand Logout
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cobrand/publicKey',
    description=""" <b>Refer GET /configs/publicKey.</b><br>The get public key service provides the customer the public key that should be used to encrypt the user credentials before sending it to Yodlee.<br>This endpoint is useful only for PKI enabled.<br> """,
    tags=['user_management', 'user_authentication'],
)
def get_public_key():
    """
    Get Public Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/configs/notifications/events',
    description=""" The get events service provides the list of events for which consumers subscribed to receive notifications. <br> """,
    tags=['event_subscription_management'],
)
def get_subscribed_notification_events(
    event_name: Optional[EventName] = Query(None, alias='eventName')
):
    """
    Get Subscribed Notification Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/configs/notifications/events/{eventName}',
    description=""" The delete events service is used to unsubscribe from an events service.<br> """,
    tags=['event_subscription_management'],
)
def delete_subscribed_notification_event(
    event_name: EventName = Path(..., alias='eventName')
):
    """
    Delete Notification Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/configs/notifications/events/{eventName}',
    description=""" The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES and AUTO_REFRESH_UPDATES event.<br><br><b>Notes:</b><li>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<li>The content type has to be passed as application/json for the body parameter.</li> """,
    tags=['event_subscription_management'],
)
def create_subscription_notification_event(
    event_name: EventName = Path(..., alias='eventName'),
    body: CreateConfigsNotificationEventRequest = ...,
):
    """
    Subscribe For Notification Event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/configs/notifications/events/{eventName}',
    description=""" The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter. <br> """,
    tags=['event_subscription_management'],
)
def update_subscribed_notification_event(
    event_name: EventName = Path(..., alias='eventName'),
    body: UpdateConfigsNotificationEventRequest = ...,
):
    """
    Update Notification Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/configs/publicKey',
    description=""" The get public key service provides the public key that should be used to encrypt user credentials while invoking POST /providerAccounts and PUT /providerAccounts endpoints.<br>This service will only work if the PKI (public key infrastructure) feature is enabled for the customer.<br><br><b>Note:</b><li> The key in the response is a string in PEM format.</li><li>This endpoint is not available in the Sandbox environment and it is useful only if the PKI feature is enabled.</li> """,
    tags=['user_authentication', 'authentication_method_management'],
)
def get_public_encryption_key():
    """
    Get Public Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dataExtracts/events',
    description=""" The get extracts events service is used to learn about occurrences of data extract related events. This service currently supports only the DATA_UPDATES event.<br>Passing the event name as DATA_UPDATES provides information about users for whom data has been modified in the system for the specified time range. To learn more, please refer to the <a href="https://developer.yodlee.com/docs/api/1.1/DataExtracts">dataExtracts</a> page.<br>You can retrieve data in increments of no more than 60 minutes over the period of the last 7 days from today's date.<br>This service is only invoked with either admin access token or a cobrand session.<br> """,
    tags=['user_data_extraction', 'event_subscription_management'],
)
def get_data_extracts_events(
    event_name: str = Query(..., alias='eventName'),
    from_date: str = Query(..., alias='fromDate'),
    to_date: str = Query(..., alias='toDate'),
):
    """
    Get Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dataExtracts/userData',
    description=""" The get user data service is used to get a user's modified data for a particular period of time for accounts, transactions, holdings, and provider account information.<br>The time difference between fromDate and toDate fields cannot be more than 60 minutes.<br>By default, pagination is available for the transaction entity in this API. In the first response, the API will retrieve 500 transactions along with other data. The response header will provide a link to retrieve the next set of transactions.<br>In the response body of the first API response, totalTransactionsCount indicates the total number of transactions the API will retrieve for the user.<br>This service is only invoked with either admin access token or a cobrand session.<br/>Refer to <a href="https://developer.yodlee.com/docs/api/1.1/DataExtracts">dataExtracts</a> page for more information.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li> """,
    tags=['user_data_extraction', 'user_account_management', 'user_management'],
)
def get_data_extracts_user_data(
    from_date: str = Query(..., alias='fromDate'),
    login_name: str = Query(..., alias='loginName'),
    to_date: str = Query(..., alias='toDate'),
):
    """
    Get userData
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/derived/holdingSummary',
    description=""" The get holding summary service is used to get the summary of asset classifications for the user.<br>By default, accounts with status as ACTIVE and TO BE CLOSED will be considered.<br>If the include parameter value is passed as details then a summary with holdings and account information is returned.<br> """,
    tags=['holding_information_management', 'financial_summary_management'],
)
def get_holding_summary(
    account_ids: Optional[str] = Query(None, alias='accountIds'),
    classification_type: Optional[str] = Query(None, alias='classificationType'),
    include: Optional[str] = None,
):
    """
    Get Holding Summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/derived/networth',
    description=""" The get networth service is used to get the networth for the user.<br>If the include parameter value is passed as details then networth with historical balances is returned. <br> """,
    tags=['financial_summary_management', 'user_data_extraction'],
)
def get_networth(
    account_ids: Optional[str] = Query(None, alias='accountIds'),
    container: Optional[str] = None,
    from_date: Optional[str] = Query(None, alias='fromDate'),
    include: Optional[str] = None,
    interval: Optional[str] = None,
    skip: Optional[int] = None,
    to_date: Optional[str] = Query(None, alias='toDate'),
    top: Optional[int] = None,
):
    """
    Get Networth Summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/derived/transactionSummary',
    description=""" The transaction summary service provides the summary values of transactions for the given date range by category type, high-level categories, or system-defined categories.<br><br>Yodlee has the transaction data stored for a day, month, year and week per category as per the availability of user's data. If the include parameter value is passed as details, then summary details will be returned depending on the interval passed-monthly is the default.<br><br><b>Notes:</b><ol> <li> Details can be requested for only one system-defined category<li>Passing categoryType is mandatory except when the groupBy value is CATEGORY_TYPE<li>Dates will not be respected for monthly, yearly, and weekly details<li>When monthly details are requested, only the fromDate and toDate month will be respected<li>When yearly details are requested, only the fromDate and toDate year will be respected<li>For weekly data points, details will be provided for every Sunday date available within the fromDate and toDate<li>This service supports the localization feature and accepts locale as a header parameter</li></ol> """,
    tags=[
        'user_data_extraction',
        'financial_summary_management',
        'transaction_operations_management',
    ],
)
def get_transaction_summary(
    account_id: Optional[str] = Query(None, alias='accountId'),
    category_id: Optional[str] = Query(None, alias='categoryId'),
    category_type: Optional[str] = Query(None, alias='categoryType'),
    from_date: Optional[str] = Query(None, alias='fromDate'),
    group_by: str = Query(..., alias='groupBy'),
    include: Optional[str] = None,
    include_user_category: Optional[bool] = Query(None, alias='includeUserCategory'),
    interval: Optional[str] = None,
    to_date: Optional[str] = Query(None, alias='toDate'),
):
    """
    Get Transaction Summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents',
    description=""" The get documents service allows customers to search or retrieve metadata related to documents. <br>The API returns the document as per the input parameters passed. If no date range is provided then all downloaded documents will be retrieved. Details of deleted documents or documents associated to closed providerAccount will not be returned. <br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br> """,
    tags=['user_data_extraction', 'document_operations'],
)
def get_documents(
    keyword: Optional[str] = Query(None, alias='Keyword'),
    account_id: Optional[str] = Query(None, alias='accountId'),
    doc_type: Optional[str] = Query(None, alias='docType'),
    from_date: Optional[str] = Query(None, alias='fromDate'),
    to_date: Optional[str] = Query(None, alias='toDate'),
):
    """
    Get Documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/documents/{documentId}',
    description=""" The delete document service allows the consumer to delete a document. The deleted document will not be returned in the get documents API. The HTTP response code is 204 (success without content).<br>Documents can be deleted only if the document related dataset attributes are subscribed.<br> """,
    tags=['document_operations'],
)
def delete_document(document_id: str = Path(..., alias='documentId')):
    """
    Delete Document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{documentId}',
    description=""" The get document details service allows consumers to download a document. The document is provided in base64.<br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br> """,
    tags=['document_operations'],
)
def download_document(document_id: str = Path(..., alias='documentId')):
    """
    Download a Document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/holdings',
    description=""" The get holdings service is used to get the list of holdings of a user.<br>Supported holding types can be employeeStockOption, moneyMarketFund, bond, etc. and is obtained using get holding type list service. <br>Asset classifications for the holdings need to be requested through the "include" parameter.<br>Asset classification information for holdings are not available by default, as it is a premium feature.<br> """,
    tags=['holding_information_management', 'user_data_extraction'],
)
def get_holdings(
    account_id: Optional[str] = Query(None, alias='accountId'),
    asset_classification_classification_type: Optional[str] = Query(
        None, alias='assetClassification.classificationType'
    ),
    classification_value: Optional[str] = Query(None, alias='classificationValue'),
    include: Optional[str] = None,
    provider_account_id: Optional[str] = Query(None, alias='providerAccountId'),
):
    """
    Get Holdings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/holdings/assetClassificationList',
    description=""" The get asset classifications list service is used to get the supported asset classifications. <br>The response includes different classification types like assetClass, country, sector, style, etc. and the values corresponding to each type.<br> """,
    tags=['holding_information_management'],
)
def get_asset_classification_list():
    """
    Get Asset Classification List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/holdings/holdingTypeList',
    description=""" The get holding types list service is used to get the supported holding types.<br>The response includes different holding types such as future, moneyMarketFund, stock, etc. and it returns the supported holding types <br> """,
    tags=['holding_information_management'],
)
def get_holding_type_list():
    """
    Get Holding Type List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/holdings/securities',
    description=""" The get security details service is used to get all the security information for the holdings<br> """,
    tags=['holding_information_management'],
)
def get_securities(holding_id: Optional[str] = Query(None, alias='holdingId')):
    """
    Get Security Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providerAccounts',
    description=""" The get provider accounts service is used to return all the provider accounts added by the user. <br>This includes the failed and successfully added provider accounts.<br> """,
    tags=['provider_account_management'],
)
def get_all_provider_accounts(
    include: Optional[str] = None,
    provider_ids: Optional[str] = Query(None, alias='providerIds'),
):
    """
    Get Provider Accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/providerAccounts',
    description=""" The update account API is used to:<br> <ul><li>Retrieve the latest information for accounts that belong to one providerAccount from the provider site. You must allow at least 15 min between requests.<li>Retrieve the latest information of all the eligible accounts that belong to the user.<li>Data to be retrieved from the provider site can be overridden using datasetName or dataset. If you do pass datasetName, all the datasets that are implicitly configured for the dataset will be retrieved. This action is allowed for single provider account refresh flows only.<li>Check the status of the providerAccount before invoking this API. Do not call this API to trigger any action on a providerAccount when an action is already in progress for the providerAccount.<li>If the customer has subscribed to the REFRESH event notification and invoked this API, relevant notifications will be sent to the customer.<li>A dataset may depend on another dataset for retrieval, so the response will include the requested and dependent datasets.<li>Check all the dataset additional statuses returned in the response because the provider account status is drawn from the dataset additional statuses.<li>Updating preferences using this API will trigger refreshes.<li> The content type has to be passed as application/json for the body parameter.</ul><br>-----------------------------------------------------------------------------------------------------------------------------------------<br><br><b>Update All Eligible Accounts - Notes:</b><br><ul><li>This API will trigger a refresh for all the eligible provider accounts(both OB and credential-based accounts).<li>This API will not refresh closed, inactive, or UAR accounts, or accounts with refreshes in-progress or recently refreshed non-OB accounts.<li>No parameters should be passed to this API to trigger this action.<li>Do not call this API often. Our recommendation is to call this only at the time the user logs in to your app because it can hamper other API calls performance.<li>The response only contains information for accounts that were refreshed. If no accounts are eligible for refresh, no response is returned.</ul> """,
    tags=['provider_account_management', 'user_account_management'],
)
def edit_credentials_or_refresh_provider_account(
    provider_account_ids: str = Query(..., alias='providerAccountIds'),
    body: ProviderAccountRequest = None,
):
    """
    Update Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providerAccounts/profile',
    description=""" The get provider accounts profile service is used to return the user profile details that are associated to the provider account. <br> """,
    tags=['user_profile_management', 'user_account_management'],
)
def get_provider_account_profiles(
    provider_account_id: Optional[str] = Query(None, alias='providerAccountId')
):
    """
    Get User Profile Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/providerAccounts/{providerAccountId}',
    description=""" The delete provider account service is used to delete a provider account from the Yodlee system. This service also deletes the accounts that are created in the Yodlee system for that provider account. <br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br> """,
    tags=['provider_account_management', 'user_account_management'],
)
def delete_provider_account(
    provider_account_id: int = Path(..., alias='providerAccountId')
):
    """
    Delete Provider Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providerAccounts/{providerAccountId}',
    description=""" The get provider account details service is used to learn the status of adding accounts and updating accounts.<br>This service has to be called continuously to know the progress level of the triggered process. This service also provides the MFA information requested by the provider site.<br>When <i>include = credentials</i>, questions is passed as input, the service returns the credentials (non-password values) and questions stored in the Yodlee system for that provider account. <br><br><b>Note:</b> <li>The password and answer fields are not returned in the response.</li> """,
    tags=['provider_account_management', 'user_account_management'],
)
def get_provider_account(
    include: Optional[str] = None,
    provider_account_id: int = Path(..., alias='providerAccountId'),
    request_id: Optional[str] = Query(None, alias='requestId'),
):
    """
    Get Provider Account Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/providerAccounts/{providerAccountId}/preferences',
    description=""" This endpoint is used to update preferences like data extracts and auto refreshes without triggering refresh for the providerAccount.<br>Setting isDataExtractsEnabled to false will not trigger data extracts notification and dataExtracts/events will not reflect any data change that is happening for the providerAccount.<br>Modified data will not be provided in the dataExtracts/userData endpoint.<br>Setting isAutoRefreshEnabled to false will not trigger auto refreshes for the provider account.<br> """,
    tags=['provider_account_management'],
)
def update_preferences(
    provider_account_id: int = Path(..., alias='providerAccountId'),
    body: ProviderAccountPreferencesRequest = ...,
):
    """
    Update Preferences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providers',
    description=""" The get provider service is used to get all the providers that are enabled, search a provider service by name or routing number and get popular sites of a region. <br>Searching for a provider using a routing number is applicable only to the USA and Canada regions.<br>The valid values for priority are: <br>   1. cobrand: Returns providers enabled for the cobrand (Default priority)<br>   2. popular: Returns providers popular among users of the customer<br><br>Only the datasets, attributes, and containers that are enabled for the customer will be returned in the response.<br>Input for the dataset$filter should adhere to the following expression:<br><dataset.name>[<attribute.name>.container[<container> OR <container>] OR <attribute.name>.container[<container>]] <br>OR <dataset.name>[<attribute.name> OR <attribute.name>]<br><b>dataset$filter value examples:</b><br>ACCT_PROFILE[FULL_ACCT_NUMBER.container[bank OR investment OR creditCard]]<br>ACCT_PROFILE[FULL_ACCT_NUMBER.container[bank]]<br>BASIC_AGG_DATA[ACCOUNT_DETAILS.container[bank OR investment] OR HOLDINGS.container[bank]] OR ACCT_PROFILE[FULL_ACCT_NUMBER.container[bank]]<br>BASIC_AGG_DATA<br>BASIC_AGG_DATA OR ACCT_PROFILE<br>BASIC_AGG_DATA [ ACCOUNT_DETAILS OR HOLDINGS ]<br>BASIC_AGG_DATA [ ACCOUNT_DETAILS] OR DOCUMENT <br>BASIC_AGG_DATA [ BASIC_ACCOUNT_INFO OR ACCOUNT_DETAILS ] <br><br>The fullAcountNumberFields is specified to filter the providers that have paymentAccountNumber or unmaskedAccountNumber support in the FULL_ACCT_NUMBER dataset attribute.<br><b>Examples for usage of fullAccountNumberFields </b><br>dataset$filter=ACCT_PROFILE[ FULL_ACCT_NUMBER.container [ bank ]] &amp; fullAccountNumberFields=paymentAccountNumber<br>dataset$filter=ACCT_PROFILE[ FULL_ACCT_NUMBER.container [ bank ]] &amp; fullAccountNumberFields=unmaskedAccountNumber<br>dataset$filter=ACCT_PROFILE[ FULL_ACCT_NUMBER.container [ bank ]] &amp; fullAccountNumberFields=unmaskedAccountNumber,paymentAccountNumber<br><br>The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively.<br>The response header provides the links to retrieve the next and previous set of transactions.<br><br><b>Note:</b> <ol><li>In a product flow involving user interaction, Yodlee recommends invoking this service with filters.<li>Without filters, the service may perform slowly as it takes a few minutes to return data in the response.<li>The AuthParameter appears in the response only in case of token-based aggregation sites.<li>The pagination feature only applies when the priority parameter is set as cobrand. If no values are provided in the skip and top parameters, the API will only return the first 500 records.<li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in query parameter and response.</li></ol> """,
    tags=['provider_account_management'],
)
def get_all_providers(
    capability: Optional[str] = None,
    dataset_filter: Optional[str] = Query(None, alias='dataset$filter'),
    full_account_number_fields: Optional[str] = Query(
        None, alias='fullAccountNumberFields'
    ),
    institution_id: Optional[int] = Query(None, alias='institutionId'),
    name: Optional[str] = None,
    priority: Optional[str] = None,
    provider_id: Optional[str] = Query(None, alias='providerId'),
    skip: Optional[int] = None,
    top: Optional[int] = None,
):
    """
    Get Providers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providers/count',
    description=""" The count service provides the total number of providers that get returned in the GET /providers depending on the input parameters passed.<br>If you are implementing pagination for providers, call this endpoint before calling GET /providers to know the number of providers that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /providers endpoint<br><br><b>Note:</b> <li>The capability has been deprecated in the query parameter.</li> """,
    tags=['provider_account_management'],
)
def get_providers_count(
    capability: Optional[str] = None,
    dataset_filter: Optional[str] = Query(None, alias='dataset$filter'),
    full_account_number_fields: Optional[str] = Query(
        None, alias='fullAccountNumberFields'
    ),
    name: Optional[str] = None,
    priority: Optional[str] = None,
):
    """
    Get Providers Count
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providers/{providerId}',
    description=""" The get provider detail service is used to get detailed information including the login form for a provider.<br>The response is a provider object that includes information such as name of the provider, <br>provider's base URL, a list of containers supported by the provider, the login form details of the provider, etc.<br>Only enabled datasets, attributes and containers gets returned in the response.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in the response. """,
    tags=['provider_account_management'],
)
def get_provider(provider_id: int = Path(..., alias='providerId')):
    """
    Get Provider Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/statements',
    description=""" The statements service is used to get the list of statement related information. <br>By default, all the latest statements of active and to be closed accounts are retrieved for the user. <br>Certain sites do not have both a statement date and a due date. When a fromDate is passed as an input, all the statements that have the due date on or after the passed date are retrieved. <br>For sites that do not have the due date, statements that have the statement date on or after the passed date are retrieved. <br>The default value of "isLatest" is true. To retrieve historical statements isLatest needs to be set to false.<br> """,
    tags=[
        'user_account_management',
        'user_data_extraction',
        'financial_summary_management',
    ],
)
def get_statements(
    account_id: Optional[str] = Query(None, alias='accountId'),
    container: Optional[str] = None,
    from_date: Optional[str] = Query(None, alias='fromDate'),
    is_latest: Optional[str] = Query(None, alias='isLatest'),
    status: Optional[str] = None,
):
    """
    Get Statements
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions',
    description=""" The Transaction service is used to get a list of transactions for a user.<br>By default, this service returns the last 30 days of transactions from today's date.<br>The keyword parameter performs a contains search on the original, consumer, and simple description attributes, replace the special characters #, &, and + with percent-encoding values %23, %26, and %2B respectively. Eg: for -Debit# , pass the input as -Debit%23.<br>Values for categoryId parameter can be fetched from get transaction category list service.<br> The categoryId is used to filter transactions based on system-defined category as well as user-defined category.<br>User-defined categoryIds should be provided in the filter with the prefix ''U''. E.g. U10002<br>The skip and top parameters are used for pagination. In the skip and top parameters pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of transactions.<br>Double quotes in the merchant name will be prefixed by backslashes (&#92;) in the response, e.g. Toys "R" Us. <br>sourceId is a unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts. Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.<br><br><b>Note</b><li> <a href="https://developer.yodlee.com/docs/api/1.1/Transaction_Data_Enrichment">TDE</a> is made available for bank and card accounts and for the US market only.The address field in the response is available only when the TDE key is turned on.<li>The pagination feature is available by default. If no values are passed in the skip and top parameters, the API will only return the first 500 transactions.<li>This service supports the localization feature and accepts locale as a header parameter.<br> """,
    tags=[
        'user_data_extraction',
        'transaction_operations_management',
        'financial_summary_management',
    ],
)
def get_transactions(
    account_id: Optional[str] = Query(None, alias='accountId'),
    base_type: Optional[str] = Query(None, alias='baseType'),
    category_id: Optional[str] = Query(None, alias='categoryId'),
    category_type: Optional[str] = Query(None, alias='categoryType'),
    container: Optional[str] = None,
    detail_category_id: Optional[str] = Query(None, alias='detailCategoryId'),
    from_date: Optional[str] = Query(None, alias='fromDate'),
    high_level_category_id: Optional[str] = Query(None, alias='highLevelCategoryId'),
    keyword: Optional[str] = None,
    skip: Optional[int] = None,
    to_date: Optional[str] = Query(None, alias='toDate'),
    top: Optional[int] = None,
    type: Optional[str] = None,
):
    """
    Get Transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/categories',
    description=""" The categories service returns the list of available transaction categories.<br>High level category is returned in the response only if it is opted by the customer.<br>When invoked by passing the cobrand session or admin access token, this service returns the supported transaction categories at the cobrand level. <br>When invoked by passing the cobrand session and the user session or user access token, this service returns the transaction categories <br>along with user-defined categories.<br>Double quotes in the user-defined category name will be prefixed by backslashes (&#92;) in the response, <br>e.g. Toys "R" Us.<br/>Source and id are the primary attributes of the category entity.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li> """,
    tags=[
        'transaction_categorization_rules_management',
        'transaction_operations_management',
    ],
)
def get_transaction_categories():
    """
    Get Transaction Category List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/categories',
    description=""" The create transaction categories service is used to create user-defined categories for a system-defined category.<br>The parentCategoryId is the system-defined category id.This can be retrieved using get transaction categories service.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 201 (Created successfully).<br> """,
    tags=[
        'transaction_categorization_rules_management',
        'transaction_operations_management',
    ],
)
def create_transaction_category(body: TransactionCategoryRequest):
    """
    Create Category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/transactions/categories',
    description=""" The update transaction categories service is used to update the transaction category name<br>for a high level category, a system-defined category and a user-defined category.<br>The renamed category can be set back to the original name by passing an empty string for categoryName.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 204 (Success without content).<br> """,
    tags=['transaction_categorization_rules_management'],
)
def update_transaction_category(body: UpdateCategoryRequest):
    """
    Update Category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/categories/rules',
    description=""" The get transaction categorization rule service is used to get all the categorization rules.<br> """,
    tags=['transaction_categorization_rules_management'],
)
def get_transaction_categorization_rules_deprecated():
    """
    Get Transaction Categorization Rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/categories/rules',
    description=""" The Create or Run Transaction Categorization Rule endpoint is used to: <br>Create transaction categorization rules for both system and user-defined categories.<br>Run all the transaction categorization rules to categorize transactions by calling the endpoint with action=run as the query parameter. <br><br>The input body parameters to create transaction categorization rules follow:<br>     categoryId - This field is mandatory and numeric<br>     priority - This field is optional and numeric. Priority decides the order in which the rule gets applied on transactions.<br>     ruleClause - This field is mandatory and should contain at least one rule<br>     field - The value can be description or amount<br><br>       If the field value is description then,<br>         1. operation - value can be stringEquals or stringContains<br>         2. value - value should be min of 3 and max of 50 characters<br><br>       If the field value is amount then, <br>         1. operation - value can be numberEquals, numberLessThan, numberLessThanEquals, numberGreaterThan or numberGreaterThanEquals<br>         2. value - min value 0 and a max value of 99999999999.99 is allowed<br>The HTTP response code is 201 (Created Successfully). """,
    tags=['transaction_categorization_rules_management'],
)
def create_or_run_transaction_categorization_rules(
    action: Optional[str] = None,
    rule_param: Optional[str] = Query(None, alias='ruleParam'),
):
    """
    Create or Run Transaction Categorization Rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/transactions/categories/rules/{ruleId}',
    description=""" The delete transaction categorization rule service is used to delete the given user-defined transaction categorization rule for both system-defined category as well as user-defined category.<br>This will delete all the corresponding rule clauses associated with the rule.<br>The HTTP response code is 204 (Success without content).<br> """,
    tags=['transaction_categorization_rules_management'],
)
def delete_transaction_categorization_rule(rule_id: int = Path(..., alias='ruleId')):
    """
    Delete Transaction Categorization Rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/categories/rules/{ruleId}',
    description=""" The run transaction categorization rule service is used to run a rule on transactions, to categorize the transactions.<br>The HTTP response code is 204 (Success with no content).<br> """,
    tags=[
        'transaction_categorization_rules_management',
        'transaction_operations_management',
    ],
)
def run_transaction_categorization_rule(
    action: Action = 'run', rule_id: int = Path(..., alias='ruleId')
):
    """
    Run Transaction Categorization Rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/transactions/categories/rules/{ruleId}',
    description=""" The update transaction categorization rule service is used to update a categorization rule for both system-defined category as well as user-defined category.<br>ruleParam JSON input should be as explained in the create transaction categorization rule service.<br>The HTTP response code is 204 (Success without content).<br> """,
    tags=[
        'transaction_categorization_rules_management',
        'transaction_operations_management',
    ],
)
def update_transaction_categorization_rule(
    rule_id: int = Path(..., alias='ruleId'),
    body: TransactionCategorizationRuleRequest = ...,
):
    """
    Update Transaction Categorization Rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/categories/txnRules',
    description=""" The get transaction categorization rule service is used to get all the categorization rules.<br> """,
    tags=['transaction_categorization_rules_management'],
)
def get_transaction_categorization_rules():
    """
    Get Transaction Categorization Rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/transactions/categories/{categoryId}',
    description=""" The delete transaction categories service is used to delete the given user-defined category.<br>The HTTP response code is 204 (Success without content).<br> """,
    tags=['user_management', 'transaction_categorization_rules_management'],
)
def delete_transaction_category(category_id: int = Path(..., alias='categoryId')):
    """
    Delete Category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/count',
    description=""" The count service provides the total number of transactions for a specific user depending on the input parameters passed.<br>If you are implementing pagination for transactions, call this endpoint before calling GET /transactions to know the number of transactions that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /transactions endpoint.<br> """,
    tags=[
        'user_data_extraction',
        'financial_summary_management',
        'transaction_operations_management',
    ],
)
def get_transactions_count(
    account_id: Optional[str] = Query(None, alias='accountId'),
    base_type: Optional[str] = Query(None, alias='baseType'),
    category_id: Optional[str] = Query(None, alias='categoryId'),
    category_type: Optional[str] = Query(None, alias='categoryType'),
    container: Optional[str] = None,
    detail_category_id: Optional[str] = Query(None, alias='detailCategoryId'),
    from_date: Optional[str] = Query(None, alias='fromDate'),
    high_level_category_id: Optional[str] = Query(None, alias='highLevelCategoryId'),
    keyword: Optional[str] = None,
    to_date: Optional[str] = Query(None, alias='toDate'),
    type: Optional[str] = None,
):
    """
    Get Transactions Count
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/transactions/{transactionId}',
    description=""" The update transaction service is used to update the category,consumer description, memo for a transaction.<br>The HTTP response code is 204 (Success without content).<br> """,
    tags=['transaction_operations_management'],
)
def update_transaction(
    transaction_id: int = Path(..., alias='transactionId'),
    body: TransactionRequest = ...,
):
    """
    Update Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user',
    description=""" The get user details service is used to get the user profile information and the application preferences set at the time of user registration.<br> """,
    tags=['user_account_management', 'user_profile_management', 'user_management'],
)
def get_user():
    """
    Get User Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user',
    description=""" The update user details service is used to update user details like name, address, currency preference, etc.<br>Currency provided in the input will be respected in the <a href="https://developer.yodlee.com/api-reference#tag/Derived">derived</a> services and the amount fields in the response will be provided in the preferred currency.<br>The HTTP response code is 204 (Success without content). <br> """,
    tags=['user_account_management', 'user_profile_management', 'user_management'],
)
def update_user(body: UpdateUserRequest):
    """
    Update User Details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/accessTokens',
    description=""" The Get Access Tokens service is used to retrieve the access tokens for the application id(s) provided.<br>URL in the response can be used to launch the application for which token is requested.<br><br><b>Note:</b> <li>This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br> """,
    tags=['user_authentication', 'authentication_method_management'],
)
def get_access_tokens(app_ids: str = Query(..., alias='appIds')):
    """
    Get Access Tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user/logout',
    description=""" <b>Deprecated</b>: This endpoint is deprecated for API Key-based authentication. The user logout service allows the user to log out of the application.<br>The service does not return a response body. The HTTP response code is 204 (Success with no content).<br> """,
    tags=['user_authentication', 'user_management'],
)
def user_logout():
    """
    User Logout
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user/register',
    description=""" The register user service is used to register a user in Yodlee.<br>The loginName cannot include spaces and must be between 3 and 150 characters.<br>locale passed must be one of the supported locales for the customer. <br>Currency provided in the input will be respected in the derived services and the amount fields in the response will be provided in the preferred currency.<br>userParam is accepted as a body parameter. <br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter.</li> """,
    tags=['user_account_management', 'user_management'],
)
def register_user(body: UserRequest):
    """
    Register User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user/samlLogin',
    description=""" The SAML login service is used to authenticate system users with a SAML response.<br>A new user will be created with the input provided if that user isn't already in the system.<br>For existing users, the system will make updates based on changes or new information.<br>When authentication is successful, a user session token is returned.<br><br><b>Note:</b> <li>The content type has to be passed as application/x-www-form-urlencoded. <li>issuer, source and samlResponse should be passed as body parameters.</li> """,
    tags=['user_authentication', 'authentication_method_management'],
)
def saml_login(
    issuer: str,
    saml_response: str = Query(..., alias='samlResponse'),
    source: Optional[str] = None,
):
    """
    Saml Login
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/unregister',
    description=""" The delete user service is used to delete or unregister a user from Yodlee. <br>Once deleted, the information related to the users cannot be retrieved. <br>The HTTP response code is 204 (Success without content)<br> """,
    tags=['user_account_management', 'user_management'],
)
def unregister():
    """
    Delete User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/verification',
    description=""" The get verification status service is used to retrieve the verification status of all accounts for which the MS or CDV process has been initiated.<br>For the MS process, the account details object returns the aggregated information of the verified accounts. For the CDV process, the account details object returns the user provided account information.<br> """,
    tags=['user_verification_processes', 'user_account_management'],
)
def get_verification_status(
    account_id: Optional[str] = Query(None, alias='accountId'),
    provider_account_id: Optional[str] = Query(None, alias='providerAccountId'),
    verification_type: Optional[str] = Query(None, alias='verificationType'),
):
    """
    Get Verification Status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verification',
    description=""" The post verification service is used to initiate the matching service (MS) and the challenge deposit account verification (CDV) process to verify account ownership.<br>The MS and CDV process can verify ownership of only bank accounts (i.e., checking and savings).<br>The MS verification can be initiated only for an already aggregated account or a providerAccount.<br>The prerequisite for the MS verification process is to request the ACCT_PROFILE dataset with the HOLDER_NAME attribute.<br>In the MS verification process, a string-match of the account holder name with the registered user name is performed instantaneously. You can contact the Yodlee CustomerCare to configure the full name or only the last name match.<br>Once the CDV process is initiated Yodlee will post the microtransaction (i.e., credit and debit) in the user's account. The CDV process takes 2 to 3 days to complete as it requires the user to provide the microtransaction details.<br>The CDV process is currently supported only in the United States.<br>The verificationId in the response can be used to track the verification request.<br><br><b>Notes:</b><li>This endpoint cannot be used to test the CDV functionality in the developer sandbox or test environment. You will need a money transmitter license to implement the CDV functionality and also require the Yodlee Professional Services team's assistance to set up a dedicated environment. """,
    tags=['user_verification_processes', 'user_account_management'],
)
def initiate_matching_or_challenge_deposite_verification(body: VerificationRequest):
    """
    Initiaite Matching Service and Challenge Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/verification',
    description=""" The put verification service is used to complete the challenge deposit verification (CDV) process.<br>This service is used only by the customer of CDV flow.<br>In the CDV process, the user-provided microtransaction details (i.e., credit and debit) is matched against the microtransactions posted by Yodlee. For a successful verification of the account's ownership both the microtransaction details should match.<br>The CDV process is currently supported only in the United States.<br><br><b>Notes:</b><ul><li>This endpoint cannot be used to test the CDV functionality in the developer sandbox or test environment. You will need a money transmitter license to implement the CDV functionality and also require the Yodlee Professional Services team's assistance to set up a dedicated environment.</li></ul> """,
    tags=['user_verification_processes', 'user_management'],
)
def verify_challenge_deposit(body: UpdateVerificationRequest):
    """
    Verify Challenge Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifyAccount/{providerAccountId}',
    description=""" The verify account service is used to verify the account's ownership by  matching the transaction details with the accounts aggregated for the user.<br><ul><li>If a match is identified, the service returns details of all the accounts along with the matched transaction's details.<li>If no transaction match is found, an empty response will be returned.<li>A maximum of 5 transactionCriteria can be passed in a request.<li>The baseType, date, and amount parameters should mandatorily be passed.<li>The optional dateVariance parameter cannot be more than 7 days. For example, +7, -4, or +/-2.<li>Pass the container or accountId parameters for better performance.<li>This service supports the localization feature and accepts locale as a header parameter.</li></ul> """,
    tags=[
        'user_account_management',
        'provider_account_management',
        'user_verification_processes',
    ],
)
def initiate_account_verification(
    provider_account_id: str = Path(..., alias='providerAccountId'),
    body: VerifyAccountRequest = ...,
):
    """
    Verify Accounts Using Transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
